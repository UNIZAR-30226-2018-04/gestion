\section{Análisis y diseño del sistema}
\label{analisis}
\subsection{Análisis de requisitos}
\label{requisitos}

\begin{table}[H]
\centering
\begin{tabular}{|c|p{12cm}|}
\hline
\multicolumn{2}{|c|}{GUIÑOTE} \\ \hline
RF-1 &  El sistema permite a los usuarios jugar al guiñote en modo uno contra uno y dos contra dos. \\ \hline
RF-2 & El sistema almacena un historial de partidas jugadas por el usuario y permite visualizar estadísticas de las partidas jugadas. \\ \hline
RF-3 & El jugador, en mitad de una partida, puede desconectarse y   volver a conectarse desde cualquier dispositivo siempre que no sea su turno o, en caso de serlo, no agote su tiempo de turno. \\ \hline
RF-4 & El sistema requiere que los usuarios se registren con su correo electrónico o Facebook para poder acceder a los servicios que ofrece. \\ \hline
RF-5 & El jugador puede seleccionar si desea jugar una partida pública o privada. \\ \hline
RF-6 & Los usuarios pueden elegir una partida pública en curso y unirse a ella como espectadores. \\ \hline
RF-7 & El sistema cuenta con una divisa virtual que se consigue al iniciar sesión por primera vez, ganando torneos, partidas, ascensos a otra liga, etc. \\ \hline
RF-8 & El sistema consta de un panel de administración al cual se pueden conectar solamente los usuarios definidos como administradores con anterioridad. \\ \hline
RF-9 & El sistema permite al usuario administrar sus datos personales almacenados en el sistema: nombre de usuario, avatar, correo electrónico. \\ \hline
RF-10 & El usuario debe conectarse utilizando el navegador web Google Chrome para garantizar el correcto funcionamiento del sistema. \\ \hline
RF-24 & El usuario puede jugar contra un agente de inteligencia artificial, únicamente en el modo uno contra uno.  \\ \hline
RNF-1 & El sistema garantiza la seguridad de la información de los usuarios. \\ \hline
RNF-2 & El sistema permite la conexión desde diferentes dispositivos. La aplicación es responsive por lo que se muestra de forma diferente para cada uno de los diferentes tamaños de pantalla. \\ \hline
RNF-3 & El sistema tarda menos de 20 segundos en encontrar partida aleatoria en caso de que haya un número de jugadores suficientes esperando para iniciar partida con las mismas características. \\ \hline
\end{tabular}
\caption{Requisitos relacionados con la jugabilidad y el usuario}
\label{tabla-usuario}
\end{table}


\begin{table}[H]
\centering
\begin{tabular}{|c|p{12cm}|}
\hline
\multicolumn{2}{|c|}{LIGAS} \\ \hline
RF-11 & Los jugadores tienen asociada una puntuación que varía en función de las partidas ganadas o perdidas. Dependiendo de ésta, pertenecerán a una u otra liga. \\ \hline
RF-12 & El sistema primero intenta emparejar a los jugadores de la misma liga. Si no es posible, los empareja con los de la liga más cercana a la suya. \\ \hline
RF-13 & Si el usuario no realiza ninguna acción durante su turno, la partida se termina y él recibe una penalización de puntuación. El turno es un periodo de tiempo preestablecido. \\ \hline
RF-14 & El sistema permite que los jugadores abandonen manualmente una partida de liga con una penalización asociada a su puntuación. \\ \hline
RNF-4 & Para ascender a una liga superior el jugador debe haber ganado muchas partidas. \\ \hline
\end{tabular}
\caption{Requisitos de las ligas}
\label{tabla-ligas}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{|c|p{12cm}|}
\hline
\multicolumn{2}{|c|}{TORNEOS} \\ \hline
RF-15 & El sistema permite a los usuarios inscribirse y participar en torneos. Los torneos son competiciones con eliminatorias directas a una partida única, en las cuales se pasa a la siguiente ronda ganando la partida. \\ \hline
RF-16 & Por cada ronda del torneo ganada el jugador recibe una puntuación proporcional a la ronda del torneo siendo la mayor bonificación la del ganador del torneo. \\ \hline
RF-17 & Los jugadores que abandonen una partida de un torneo son descalificados con una penalización asociada a su puntuación. \\ \hline
RF-18 & El administrador puede programar la creación automática de torneos ya sean puntuales o periódicos, especificando un momento de inicio y unos premios determinados. \\ \hline
RF-19 & El administrador puede modificar y eliminar torneos que aún no estén en curso. \\ \hline
RNF-5 & La puntuación recibida en cada fase por ganar una partida es mucho mayor que la recibida en una partida de liga y el doble que la de la fase anterior del mismo torneo. La puntuación para el campeón y el subcampeón es mucho más grande que la de los otros participantes. \\ \hline
RNF-6 & Los torneos programados inicialmente son semanales. \\ \hline
\end{tabular}
\caption{Requisitos de los torneos}
\label{tabla-torneo}
\end{table}

\begin{table}[H]
\centering
\label{tabla-tienda}
\begin{tabular}{|c|p{12cm}|}
\hline
\multicolumn{2}{|c|}{TIENDA} \\ \hline
RF-20 & El sistema posee una tienda para personalizar el tablero de juego, las barajas y el avatar, que inicialmente consta de 3 barajas, 3 tableros y 20 avatares diferentes. \\ \hline
RF-21 & El administrador de la aplicación puede añadir artículos nuevos a la tienda y modificar el   precio de los existentes \\ \hline
RF-22 & Los artículos de la tienda se desbloquean en función de la liga más alta en la que ha participado el usuario en algún momento. \\ \hline
RF-23 & Los artículos se compran con la divisa virtual que el usuario tiene acumuladas. \\ \hline
RNF-7 & El valor en divisas virtuales de las barajas es más mayor que el de los tableros. El precio de los avatares varía para cada uno de ellos y para conseguirlos el jugador debe haber ganado muchas partidas. \\ \hline
\end{tabular}
\caption{Requisitos de la tienda}
\end{table}


\subsection{Diseño del sistema}
Se ha decidido implementar una aplicación web de 3 capas porque como se accede desde el navegador para hacer un cambio en la interfaz no hace falta una actualización en cada nodo cliente, siempre que la nueva interfaz sea compatible con Google Chrome 64 o posteriores. Además, como el modelo se aloja en un servidor distinto al de la base datos cualquier cambio en una de las partes no afecta al resto del sistema ya que se comunica mediante una interfaz bien definida al comienzo del proyecto. 
Otra ventaja de las aplicaciones en tres capas es que es muy fácil encontrar documentación y ejemplos de otras aplicaciones parecidas en internet ya que hoy en día son las más utilizadas. \\
No se ha elegido un modelo de aplicación de 4 capas porque resulta un inconveniente que la interfaz se ejecute en un servidor central ya que sería un cuello de botella importante para el sistema dado que gran parte del tiempo de ejecución del sistema corresponde a la interfaz. \\

La distribución de las diferentes partes se puede apreciar en el diagrama de componentes de la figura \ref{fig:diagramaComponentes}

\begin{figure}[H]
\centering
\includegraphics[scale = 0.5]{figuras/diagramaComponentes.png}
\caption{Diagrama de componentes donde se refleja la distribución del sistema}
\label{fig:diagramaComponentes}
\end{figure}

\subsubsection{Interfaz}
La interfaz se ha desarrollado utilizando la herramienta Phaser, basada en JavaScript. Se ha implementado de manera que sea fácilmente modificable ya que a lo largo de la producción del software se han de introducir cambios, por lo que se han parametrizado la mayoría de las funciones en medida de lo posible.

Una de las principales decisiones de diseño que se han tenido que llevar a cabo es como representar a cada jugador. Se ha hecho de manera que cada jugador tiene su posición como referencia y la interfaz es capaz de representar al resto en función de éste. Como hay un máximo de 4 jugadores, la interfaz toma cada posición como un rol,  teniendo todos los roles los mismos parámetros simulando un patrón de diseño Strategy, para facilitar la integración. El diagrama de clases de la figura \ref{fig:clasesInterfazJuego} muestra la implementación de la interfaz. Aunque en JavaScript no haya clases como tal, se ha aprovechado la sintaxis UML para visualizar las diferentes partes.

\begin{figure}[H]
  \includegraphics[width=\linewidth]{figuras/clasesInterfazJuego.png}
  \caption{Diagrama de clases de la interfaz de juego}
  \label{fig:clasesInterfazJuego}
\end{figure}

Otra decisión de diseño que sobre la que se ha reflexionado ha sido acerca de la comunicación entre la interfaz y el controlador de la partida. La tecnología que se ha escogido han sido WebSockets como se ha dicho previamente. Dicha tecnología permite únicamente comunicarse a través del paso de mensajes, por lo que se ha decidido que los mensajes sean en formato JSON para que sean fácilmente legibles para ambos extremos de la comunicación.

La aplicación web que no se corresponda con la parte jugable, es decir, el perfil del usuario, la vista del historial de partidas, ligas, torneos, etc. se implementa con JSP y servlets.

Una vez se ha desarrollado el sistema, con todas las vistas ya implementadas, el mapa de navegación resultante se observa en la figura \ref{fig:mapaDeNavegacionFinal}. También se puede consultar en el Anexo IV el prototipo del mapa de navegación de la aplicación desarrollado en las fases iniciales del proyecto.

\begin{figure}[H]
  \includegraphics[width=\linewidth]{figuras/mapaNavFinal.png}
  \caption{Mapa de navegación final}
  \label{fig:mapaDeNavegacionFinal}
\end{figure}

\subsubsection{Gestor de mensajes (Netcode)}

Para poder sincronizar los eventos que suceden en una partida entre el servidor y todos los clientes se usan websockets,
siendo el gestor de mensajes un endpoint de websockets seguros en la URL "wss://[raíz]/gm/endpoint". 
El ciclo de vida de una partida comienza recibiendo el gestor los mensajes de listoJugador. Una vez se reciben los de todos,
se les envía un estado inicial de la partida con toda la información necesaria. Después, cada jugador informa de los eventos
sucedidos en su cliente al gestor, el cual se encarga de verificar su coherencia y retransmitirlo al resto de clientes. Al
informar de los eventos de forma incremental, se evita el overhead de tener que enviar el estado completo cada vez. El único
momento en el que es imposible evitar el mandar el estado completo es en la transición de idas a vueltas.\\

\begin{figure}[H]
\includegraphics[width=\linewidth]{figuras/diagramasSecuencia/partidaCompleta1.png}
\caption{Diagrama de secuencia de una partida completa}
\label{fig:partidaCompleta1}
\end{figure}

\begin{figure}[H]
\includegraphics[width=\linewidth]{figuras/diagramasSecuencia/partidaCompleta2.png}
\caption{Diagrama de secuencia de una partida completa}
\label{fig:partidaCompleta2}
\end{figure}

Como caso interesantes se encuentra la desconexión/reconexión de jugadores, que se gestiona notificando al resto de jugadores
de un timeout para programar una "alarma". Si antes de recibir el gestor la "alarma" de cualquiera de los otros jugadores, recibe
un mensaje listoJugador del ausente, se entiende que se reconecta y se le envía el estado de la partida en ese momento, notificando
también al resto de jugadores. La otra posibilidad es que se reciba el timeout antes de que se reconecte, lo que significa que
el jugador ha expirado su tiempo, finalizando la partida y notificando a los jugadores.\\

\begin{figure}[H]
  \includegraphics[width=\linewidth]{figuras/diagramasSecuencia/desconexion.png}
  \caption{Caso de desconexión/reconexión de jugador}
  \label{fig:desconexion}
\end{figure}

El otro caso interesante es la gestión de los espectadores, que básicamente son tratados como jugadores en el sentido de que son
notificados de todos los eventos acontecidos pero no pueden emitir ningún evento. Además, su reconexión tampoco es gestionada
ya que no influye para el desarrollo de la partida.\\

\begin{figure}[H]
  \includegraphics[width=\linewidth]{figuras/diagramasSecuencia/espectador.png}
  \caption{Gestión de espectadores}
  \label{fig:espectador}
\end{figure}

\subsubsection{Emparejamiento (Matchmaking)}
Una de las funcionalidades principales de la aplicación consiste en permitir que los jugadores encuentren a otros de su mismo nivel
para jugar automáticamente. Esta funcionalidad la gestiona el endpoint de websockets seguros "wss://[raíz]/mm/matchmaking". 
La secuencia de búsqueda de partida es relativamente sencilla: El jugador que busca partida envía un mensaje con los parámetros de 
la partida deseada. En caso de que sea con la IA, se crea una partida nueva y se le redirige inmediatamente. En el resto de casos,
si hay suficientes jugadores buscando una partida de las mismas características y pertenecen a la misma liga, se les empareja y son
redirigidos a su partida. Además, el jugador envía periódicamente mensajes informando de que sigue buscando, de forma que si excede
un número determinado de "sigo buscandos", se le empareja con un jugador de cualquier liga ya que se considera que ha esperado 
demasiado tiempo y jugar con alguien de diferente nivel tiene un impacto menos negativo sobre la experiencia de usuario que estar esperando
largos periodos de tiempo.\\

\begin{figure}[H]
  \includegraphics[width=\linewidth]{figuras/diagramasSecuencia/buscarPartida.png}
  \caption{Búsqueda de partida}
  \label{fig:buscarPartida}
\end{figure}

Además, este endpoint se encarga de gestionar también los torneos, de forma que cuando un jugador busca torneo envía un mensaje buscoTorneo
con el identificador del torneo. El endpoint le contesta con el tiempo restante hasta la hora límite de comienzo del torneo. En cuanto haya
un número suficiente de jugadores, se les empareja en partidas y se les redirige. Sin embargo, si llegada la hora límite no está lleno el torneo,
los jugadores esperando envían un mensaje empezarTorneo al endpoint, que rellena los huecos del torneo con IAs.\\

\begin{figure}[H]
  \includegraphics[width=\linewidth]{figuras/diagramasSecuencia/buscarTorneo.png}
  \caption{Búsqueda de torneos}
  \label{fig:buscarTorneo}
\end{figure}

\subsubsection{Lógica y BackEnd}

Para la implementación de la lógica del juego se ha analizado el dominio del problema y se ha realizado un primer diseño de clases de análisis. Posteriormente se ha implementado objeto a objeto el diseño inicial y al mismo tiempo actualizado el diagrama de clases. 


\begin{figure}[H]
\hspace{-1cm}
\includegraphics[scale = 0.5]{figuras/logica_juego/diagramaClasesDisenyo.png}
\caption{Diagrama de clases en la fase de análisis del problema}
\label{fig:diagramaClasesLogicaJuegoInicial}
\end{figure}

% \begin{figure}[H]
% \hspace{-2cm}
% \includegraphics[scale = 0.4]{figuras/logica_juego/diagramaClasesImplementacion.png}
% \caption{Diagrama de clases final}
% \label{fig:diagramaClasesLogicaJuegoFinal}
% \end{figure}


\subsubsection{Base de Datos}
El primer paso en el diseño de la base de datos fue plantear el esquema entidad relación como esquema conceptual del problema. Una vez diseñado el paso a un esquema relacional fue sencillo.

\begin{figure}[H]
\centering
\includegraphics[scale = 0.5]{figuras/base_datos/diagrama-conceptual.pdf}
\caption{Esquema Conceptual}
\label{fig:diagramaConceptual}
\end{figure}

Antes de llegar al esquema actual se plantearon otras posibilidades, primeramente por una falta de claridad entre los datos que debían ser persistentes y los que no. En un primer momento se creó una entidad Espera, débil respecto a un Usuario que representaba que un usuario estaba esperando para encontrar jugadores. Finalmente la entidad no existe y la información de una espera no es almacenada en la base de datos. Las partidas son introducidas en la base cuando se empieza una partida, para así poder tener la información de las partidas en curso. La parte con más dificultad es la relacionada con los torneos. Para representar los torneos existen las fases, entendidas como octavos, cuartos, semifinales... Una partida puede estar ligada a una fase, y la fase pertenece a un torneo. Finalmente los jugadores están relacionados con una fase para poder emparejar jugadores.\\

Para la comunicación del sistema con la base de datos se ha utilizado el patrón DAO (Objeto de Acceso a Datos). Para ello se han implementado una serie de objetos VO que representan la información guardada de forma persistente y unos objetos DAO que abstraen las operaciones con el JDBC mediante métodos de Java. Para mayor seguridad de los datos, todos los posibles usos de la base se realizan a través de una interfaz que proporciona los métodos necesarios además de ofrecer un \textit{pool} de conexiones para aumentar la velocidad de la interacción cuando haya múltiples usuarios.\\

\begin{figure}[H]
\centering
\includegraphics[scale = 0.5]{figuras/base_datos/Componentes.pdf}
\caption{Esquema de la estructura del acceso a datos}
\label{fig:componentesbases}
\end{figure}

Los clientes que usen la base de datos deben realizar todas las operaciones a través de la Interfaz de Datos. La Interfaz utiliza el pool manager para no tener que crear una nueva conexión con cada cliente y poder reutilizarlas. La Interfaz invocará a las clases DAO que utilizaran las conexiones para conectarse finalmente con la base. Las clases VO sirven para representar los objetos de la base en la comunicación entre las clases. Los diagramas de clases de la Interfaz de Datos se pueden consultar en el Anexo IV.\\

\subsubsection{Inteligencia Artificial}
Crear una inteligencia artificial para el Guiñote dista mucho de ser una tarea sencilla pues la propia lógica del juego hace que sea díficil decidir qué cartas son beneficiosas para el jugador a tirar. Las personas cuando juegan aplican unas estrategias personales que pueden variar desde guardar triunfos para el final, maximizar los puntos en cada ronda, descartarse de palos para el arrastre... y ninguna de estas estrategias es superior al resto ni garantiza ganar. Basar la IA en los mecanismos humanos no es una buena estrategia debido a que la forma de jugar de las personas está condicionada por prejuicios que han ido adquiriendo a lo largo del tiempo tras numerosas partidas por los pueblos de Aragón. Además, al tratarse de un juego poco extendido sus estrategias nunca han trascendido a niveles académicos donde hayan sido estudiadas de forma objetiva. Por ello se ha decidido que la inteligencia a desarrollar debía ser independiente de lo que a priori puedan parecer buenas jugadas. Todo esto quiere decir que el sistema en ningún momento se basa en reglas escritas manualmente por los desarrolladores.\\

Para elegir el algoritmo más adecuado se ha consultado numerosa literatura buscando juegos similares al Guiñote. Se trata de un juego con información oculta y además no determinista, es decir, no se conoce la carta del rival, y no se sabe el orden de las cartas a robar, que podría ser cualquiera, dando lugar a distintos finales de la partida.\\

El primer algoritmo que se ha tenido en cuenta es el \textit{expectiminimax}. Se ha descartado debido a que basa sus resultados en función de la probabilidad de cada carta, pero a ojos de un jugador del Guiñote, el rival puede tener cualquier carta, y cualquier carta puede ser la siguiente en ser robada.

El algoritmo final ha sido una variante del \textit{monte carlo tree search}, conocido como \textit{MCTS}. Este algoritmo es ampliamente utilizado para juegos de tablero donde el estado completo de la partida es conocido en cada momento. Basa su éxito en la realización de simulaciones desde un punto concreto de la partida. De esta forma elige el siguiente movimiento comprobando qué jugada ofrece unos resultados mas favorecedores en las simulaciones. El problema de este algoritmo es que es necesario conocer el estado completo de la partida para poder utillizarlo (saber las cartas del rival y las del mazo), y hacer trampas no es una opción viable para una inteligencia artificial.\\

La forma de solucionar la información oculta viene con una variación del algoritmo original, utilizando el \textit{information set monte carlo tree search}, conocido como \textit{ISMCTS}~\cite{ismcts}. La variación que incluye este algoritmo se basa en determinizar el estado de la partida. Conseguir el estado de la partida completo, pero debido a que es desconocido, se inventa. En cada iteración del algoritmo se 'barajan' las cartas desconocidas para la IA y se reparten al rival y al mazo de forma que en ese momento se tiene un estado conocido (aunque no tiene por qué ser real). El éxito del \textit{ISMCTS} recae en que al realizar un gran número de simulaciones, la determinización aleatoria del estado de la partida tiende a representar el estado real.

\begin{figure}[H]
\centering
\includegraphics[scale = 1]{figuras/mcts}
\caption{Fases del algoritmo \textit{MCTS} \cite{ismcts2}}
\label{fig:mcts}
\end{figure}

El esquema del algoritmo \textit{MCTS} se basa en cuatro fases, cada nodo del árbol representa un movimiento, y cada nivel representa el jugador que realiza ese movimiento:
\begin{description}
  \item[Selección: ] Se va bajando por los nodos del árbol hasta llegar a una hoja eligiendo el siguiente nodo con los resultados de la fórmula UCT basada en UCB1. Esta fórmula elige nodos que ofrecen un gran beneficio o que han sido poco explorados. El factor con el que realiza la exploración puede ser modificado a favor de mas exploración o más explotación. 
  \item[Expansión: ] Cuando se llega a un nodo hoja se generan todos sus posibles hijos, es decir, las respuestas que da el otro jugador al movimiento de esa hoja.
  \item[Simulación: ] Desde el nodo hoja al que se ha llegado se realiza una simulación en la que se van realizando movimientos aleatorios (pero posibles) hasta finalizar la partida.
  \item[Propagación: ] Cuando la simulación ha finalizado se obtiene el resultado de la partida (ganada o perdida) y se va propagando esa información hacia arriba hasta la raíz.
\end{description}

Este proceso se repite múltiples veces de forma que la simulaciones modelan el resultado real. Cuando se acaba el tiempo para realizar las iteraciones se elige como movimiento a realizar el hijo con más visitas de la raíz del árbol.

En el \textit{ISMCTS} implementado se añade un primer paso previo a las cuatro fases. En ese paso se determiniza el estado de la partida. Específicamente en el Guiñote se mezclan las cartas desconocidas por la IA y se reparten de forma que ahora se conocen aunque no representan la realidad.\\

La IA realiza las simulaciones de forma aleatoria pero siguiendo las reglas del juego, de forma que para la implementación sólo ha sido necesario conocer las reglas del Guiñote pero no ninguna estrategia de victoria. El esqueleto de la implementación se ha basado en una implementación realizada en \textit{Python} por quienes publicaron el artículo sobre el \textit{ISMCTS} \cite{ismctspy}.\\

En primer lugar se ha realizado una implementación en \textit{Python} para evaluar y validar que el algoritmo juega correctamente. Una vez comprobada la viabilidad se pasó a realizar la implementación definitiva en \textit{Java} que sería conectada con el resto de componentes del sistema. En la aplicación, se trata a la IA como un usuario más, denominado SophIA, que además tiene un avatar personalizado para que se le reconozca del resto de usuarios.\\

Con la versión definitiva se realizaron una serie de pruebas a fin de determinar el mejor número de iteraciones que no suponga una espera al usuario y el mejor factor de explotación y exploración. A fin poder comparar la IA se le han presentado cuatro distintos rivales: 
\begin{description}
  \item[Random: ] Juega una carta al azar.
  \item[Greedy: ] Jugador voraz que siempre que tira en segundo lugar intenta maximizar los puntos obtenidos (con una penalización a gastar triunfo) y cuando lanza primera minimiza los puntos. Con esta estrategia sencilla se consigue una jugada óptima local que puede representar las jugadas de un rival novato.
  \item[Cheating:] Se trata de la misma IA, pero en vez de determinizar aleatoriamente la partida, 'mira' las cartas del rival y del mazo, de forma que hace trampas.
  \item[Humano:] Ignacio Bitrián, integrante del grupo, es un gran jugador del juego y ha participado en numerosos torneos.
\end{description}

El número de iteraciones elegido finalmente ha sido 20.000. De esta forma la IA responde en menos de un segundo pero son suficientes para que suponga una notable dificultad ganarle. Para elegir el factor entre explotación y exploración se han comparado distintos factores contra los distintos rivales, obteniendo que el mejor factor es 0.7, coincidiendo con el factor que aparece en algoritmo original. Con los parámetros ajustados se han enfrentado los rivales a partidas entre ellos obteniendo la siguiente matriz de resultado:

\begin{figure}[H]
\centering
\includegraphics[scale = 0.7]{figuras/statsIA}
\caption{Matriz de resultados del algoritmo}
\label{fig:mcts}
\end{figure}

Observando la matriz de resultados se puede concluir que la IA es muy competente, consiguiendo más victorias que derrotas frente a un rival humano experimentado. La IA que hace trampas gana en bastantes ocasiones a la IA normal, pero la IA ha sabido defenderse en el 30\% de las partidas. Jugando contra el jugador voraz y el aleatorio consigue victoria en casi todas las ocasiones.

\subsubsection{Despliegue}
La aplicación se pone en marcha en un servidor Tomcat, ya que permite la instalación de aplicaciones web en formato .war. Se distinguen dos aplicaciones diferentes: la que da soporte a la lógica de la aplicación y la encargada de coordinar una partida en curso. Ambas se comunican indirectamente a través de la base de datos y están coordinadas. \\
La base de datos es relacional ya que se necesitan muchas consultas de los datos almacenados y para cada partida hay varias inserciones o actualización de los datos almacenados. El sistema gestor de la base de datos va a ser MySQL porque se ahorran costes al ser un SGBD de código abierto y no tener que adquirir una licencia de pago. Además, el equipo cuentan con experiencia en el diseño e implementación de bases de datos utilizando MySQL. \\
La razón por la que no se ha elegido otro SGBD de código abierto son los problemas que presenta RDS Aurora. Otros SGBD como PostgreSQL son más exigentes en recursos y, por lo tanto, el coste es mayor sin repercutir un beneficio real sobre la aplicación ya que se considera que MySQL es más que suficiente para una aplicación de estas características.
Otra alternativa era Oracle pero debido al alto coste de la licencia no se ha escogido. \\
El patrón de diseño utilizado para la comunicación del sistema con la base de datos es \textit{façade} ya que permite dividir el sistema completo en dos o más subsistemas consiguiendo un alto desacoplamiento de la base de datos y el juego. De esta forma, se puede dividir mejor el trabajo de forma independiente entre los equipos para poder llevar a cabo un diseño e implementación top-down.


\subsection{Tecnologías elegidas}
\begin{itemize}
\item \textbf{Interfaz de la partida en el navegador web}. La interfaz del juego consiste en una única pantalla donde los jugadores que participan en la partida en curso se comunican. Se implementa utilizando JavaScript y Phaser. Phaser es un framework para desarrollo de juegos en HTML5 basado en la tecnología JavaScript.  \\ Se ha decidido utilizar JavaScript por la sencillez a la hora de ser visualizado en un navegador y se incorpora a la perfección con HTML5. Se ha barajado la posibilidad de utilizar Flash pero se descarta por estar obsoleta y porque algunos navegadores ya no lo soportan. También se podría haber utilizado Unity pero no se ha llevado a cabo por tener una curva de aprendizaje muy complicada.
\item \textbf{Capa de comunicación de la partida}. Es el servicio que está por debajo de la partida encargado de notificar las acciones de los jugadores al resto. Además comprueba que el transcurso de la partida es correcto, como si de un coordinador se tratara. Se utiliza lenguaje Java, ya que es un servicio Web e irá desplegado a través de un archivo .war. Además, facilita la comunicación con la tecnología WebSockets, que es la que se ha escogido para comunicar en tiempo real el navegador con el controlador. Se ha decidido WebSockets por tener una curva de aprendizaje sencilla ya que se utilizará para enviar mensajes desde el navegador al controlador. Se integra perfectamente con Java. \\
Se ha descartado utilizar Sockets.io ya que va ligado a Node.js, que es una tecnología más novedosa pero que el equipo desconoce por completo, aprenderla supone un número de horas extras y se desconoce si es una tecnologia viable para la aplicación a desarrollar.
\item \textbf{Interfaz Web}. Se implementa en HTML 5 y se utiliza  JSP y Servlets para la generación de contenido dinámico y procesamiento de formularios, respectivamente. Se trata de una tecnología poco actual pero de la cuál el equipo de desarrollo tiene cierta experiencia, por lo que se asegura la calidad del servicio.
\item \textbf{Lógica y dominio de la aplicación}. Implementado en Java para favorecer la interoperabilidad con la interfaz web.
\item \textbf{Acceso a los datos}. Se utilizan objetos de tipo implementados en Java. De esta manera se cumple el patrón "Modelo - Vista - Controlador".
\item \textbf{Base de datos}. Se utiliza un Sistema Gestor de Bases de Datos relacional, ya que la principales consultas que se hacen son de tipo JOIN. Se ha decidido utilizar MySQL ya que es un sistema que el equipo domina. La desventaja es que es poco eficiente en comparación con otros como Oracle, pero para el número de usuarios que tendrá la aplicación es suficiente con dicho gestor.
\end{itemize}



%\begin{itemize}
%\item  DIAGRAMA DE DESPLIEGUE DE LA APPLICACIÓN WEB EN 3 CAPAS
%\item \textbf{Diagramas arquitecturales (de módulos, de componentes y conectores, de distribución), patrones de diseño y estilos arquitecturales que se aplicarán. Las interfaces (de módulos y de componentes) son especialmente importantes. También lo son los protocolos de comunicación entre componentes.}
%\item \textbf{Tecnologías elegidas (lenguajes de programación, componentes que se integrarán, API web externas con las que se conectará etc.)--ya está--.}

%\item \textbf{Otros aspectos técnicos de interés (p.ej. si hay base de datos si va a ser SQL,  si algunas de las operaciones van a ser asíncronas o no, si se van a usar tecnologías web, cómo se van a considerar los requisitos de seguridad o de prestaciones, cómo y dónde se harán las instalaciones y despliegues etc.)}
%\end{itemize}
%\textbf{Hay que justificar todas las decisiones de diseño. Esto exige contestar a dos preguntas sobre cada decisión: ¿qué alternativas se barajaron? y ¿por qué se eligió una y no las otras?}
